use logos::*;#[derive(Clone,Logos)]#[logos(skip r"\s")]pub enum Tokens{#[token("+")]Add,#[token("-")]Subtract,#[token("*")]#[token("ร")]Multiply,#[token("/")]#[token("รท")]Divide,#[token("(")]#[token("[")]#[token("{")]BracketStart,#[token(")")]#[token("]")]#[token("}")]BracketEnd,#[regex(r"[\d]+(\.[\d]+)?", callback = |lex| lex.slice().parse::<f64>().ok())]Number(Option<f64>),UnaryAdd,UnarySubtract,None}impl Tokens{fn percedence(&self)->Option<usize>{match self{Self::UnaryAdd|Self::UnarySubtract=>Some(3),Self::Multiply|Self::Divide=>Some(2),Self::Add|Self::Subtract=>Some(1),_=>None}}fn infer_mult(&self)->bool{matches!(self,Self::Number(_))}fn unary_form(&self)->Option<Self>{match self{Self::Add=>Some(Self::UnaryAdd),Self::Subtract=>Some(Self::UnarySubtract),_=>None}}}struct Parser{buf:Vec<(Result<Tokens,()>,Span)>,idx:usize}impl Parser{fn new(lex:&mut Lexer<Tokens>)->Self{let mut buf=Vec::new();while let Some(tok)=lex.next(){buf.push((tok,lex.span()));}Self{buf,idx:0}}fn next<'a>(&'a mut self)->Option<&'a(Result<Tokens,()>,Span)>{self.idx+=1;self.buf.get(self.idx-1)}}pub fn calculate(eval:&str)->Result<f64,String>{let mut parser=Parser::new(&mut Tokens::lexer(eval));let mut out_queue=Vec::new();let mut op_stack:Vec<(Result<Tokens,()>,Span)>=Vec::new();let mut last_tok=Tokens::None;while let Some(tok)=parser.next(){if tok.0.is_err(){return Err(format!("Unexpected `{}` (in {}..{})",&eval[tok.1.start..tok.1.end],tok.1.start,tok.1.end))}let t=tok.0.as_ref().unwrap().clone();match t{Tokens::Number(_)=>{if last_tok.infer_mult(){return Err(format!("Expected operation or ending after number, found `{}` instead (in {}..{})",&eval[tok.1.start..tok.1.end],tok.1.start,tok.1.end))}out_queue.push(tok.clone())}Tokens::Add|Tokens::Subtract|Tokens::Multiply|Tokens::Divide=>{let o=if last_tok.infer_mult(){t.clone()}else{t.unary_form().unwrap()};while let Some(op)=op_stack.last(){if matches!(op.0.as_ref().unwrap(),Tokens::BracketStart)||op.0.as_ref().unwrap().percedence().unwrap()<o.percedence().unwrap(){break}out_queue.push(op_stack.pop().unwrap())}op_stack.push((Ok(o), tok.1.clone()))}Tokens::BracketStart=>{if last_tok.infer_mult(){while let Some(op)=op_stack.last(){if matches!(op.0.as_ref().unwrap(),Tokens::BracketStart)||op.0.as_ref().unwrap().percedence().unwrap()<2{break}out_queue.push(op_stack.pop().unwrap())}op_stack.push((Ok(Tokens::Multiply),tok.1.clone()))}op_stack.push(tok.clone())}Tokens::BracketEnd=>{let mut g=true;while let Some(op)=op_stack.pop(){if matches!(op.0.as_ref().unwrap(),Tokens::BracketStart) {g^=true;break}out_queue.push(op)}if g{return Err(format!("Mismatched brackets (can't find starting brackets that matches the ending bracket at char {})",tok.1.start))}}_=>()}last_tok=t}while let Some(op)=op_stack.pop(){out_queue.push(op)}let mut results=Vec::new();for i in out_queue.into_iter(){match i.0.unwrap(){Tokens::Number(n)=>results.push(n.unwrap()),Tokens::Add=>{let rhs=results.pop().unwrap();let lhs=results.pop().unwrap();results.push(lhs+rhs)}Tokens::Subtract=>{let rhs=results.pop().unwrap();let lhs=results.pop().unwrap();results.push(lhs-rhs)}Tokens::Multiply=>{let rhs=results.pop().unwrap();let lhs=results.pop().unwrap();results.push(lhs*rhs)}Tokens::Divide=>{let rhs=results.pop().unwrap();let lhs=results.pop().unwrap();results.push(lhs+rhs)}Tokens::UnaryAdd=>{let op=results.pop().unwrap();results.push(op.abs())}Tokens::UnarySubtract=>{let op=results.pop().unwrap();results.push(-op)}Tokens::BracketStart=>return Err(format!("Mismatched brackets (can't find ending brackets that matches the starting bracket at char {})",i.1.start)),_=>()}}Ok(results[0])}
